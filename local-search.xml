<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kotlin协程</title>
    <link href="/2023/11/12/Kotlin%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/11/12/Kotlin%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="三个视频"><a href="#三个视频" class="headerlink" title="三个视频"></a>三个视频</h2><iframe src='//player.bilibili.com/player.html?bvid=BV164411C7FK&cid=116363293&p=1&share_source=copy_web' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true'></iframe><iframe src='//player.bilibili.com/player.html?bvid=BV1KJ41137E9&cid=118280196&p=1&share_source=copy_web' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true'></iframe><iframe src='//player.bilibili.com/player.html?bvid=BV1JE411R7hp&cid=120199369&p=1&share_source=copy_web' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true'></iframe><h2 id="三篇文章"><a href="#三篇文章" class="headerlink" title="三篇文章"></a>三篇文章</h2><p><a href="https://juejin.cn/post/6844903949686800392">【码上开学】Kotlin 的协程用力瞥一眼</a></p><p><a href="https://juejin.cn/post/6844903968699580430">【码上开学】Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p><p><a href="https://juejin.cn/post/6844904001238990862">【码上开学】到底什么是「非阻塞式」挂起？协程真的更轻量级吗？</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt学习-可重入和线程安全</title>
    <link href="/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p>原文地址 <a href="https://doc.qt.io/qt-6/threads-reentrancy.html">https://doc.qt.io/qt-6/threads-reentrancy.html</a></p><ul><li><p>一个线程安全的函数可以从多个线程被同时调用，即使调用使用共享数据也是如此，因为对共享数据的所有引用都是序列化的。</p></li><li><p>可重入函数也可以从多个线程被同时调用，但前提是每次调用都使用自己的数据。</p></li></ul><p>因此，线程安全函数总是可重入的，但可重入函数并不总是线程安全的。</p><p>通过扩展，<strong>如果一个类的成员函数可以从多个线程安全地调用，则该类被称为可重入的，只要每个线程使用该类的不同实例。 如果可以从多个线程安全地调用该类的成员函数，则该类是线程安全的，即使所有线程都使用该类的同一个实例</strong>。</p><p>注意：如果 Qt 类打算由多个线程使用，则它们仅被记录为线程安全的。 如果函数未标记为线程安全或可重入，则不应在不同线程中使用它。 如果某个类未标记为线程安全或可重入，则不应从不同线程访问该类的特定实例。</p><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>C++ 类通常是可重入的，仅仅是因为它们只访问它们自己的成员数据。 任何线程都可以在可重入类的实例上调用成员函数，只要没有其他线程可以同时在该类的同一实例上调用成员函数。 例如，下面的 Counter 类是可重入的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter</span>() &#123; n = <span class="hljs-number">0</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123; ++n; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123; --n; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> n; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该类不是线程安全的，因为如果多个线程试图修改数据成员 n，结果是未定义的。这是因为 ++ 和 – 运算符并不总是原子的。实际上，它们通常扩展为三个机器指令：</p><ol><li>将变量的值加载到寄存器中。</li><li>增加或减少寄存器的值。</li><li>将寄存器的值存回主存。</li></ol><p>如果线程 A 和线程 B 同时加载变量的旧值，递增它们的寄存器，然后将其存储回去，它们最终会相互覆盖，并且变量只会递增一次！</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>显然，访问必须串行化：线程 A 必须在线程 B 执行相同步骤之前不间断地（原子地）执行步骤 1、2、3； 或相反亦然。 使类线程安全的一种简单方法是使用 QMutex 保护对数据成员的所有访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter</span>() &#123; n = <span class="hljs-number">0</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>; ++n; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>; --n; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>; <span class="hljs-keyword">return</span> n; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> QMutex mutex;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br></code></pre></td></tr></table></figure><p>QMutexLocker 类在其构造函数中自动锁定互斥锁，并在函数结束时调用析构函数时将其解锁。 锁定互斥量可确保来自不同线程的访问将被序列化。 mutex 数据成员是用 mutable 限定符声明的，因为我们需要在 value() 中锁定和解锁 mutex，这是一个 const 函数。</p><h2 id="Qt-类注释"><a href="#Qt-类注释" class="headerlink" title="Qt 类注释"></a>Qt 类注释</h2><p>许多 Qt 类是可重入的，但它们不是线程安全的，因为使它们线程安全会导致重复锁定和解锁 QMutex 的额外开销。 例如，QString 是可重入的但不是线程安全的。 您可以同时从多个线程安全地访问 QString 的不同实例，但是您不能同时从多个线程安全地访问 QString 的同一个实例（除非您自己使用 QMutex 保护访问）。</p><p>一些 Qt 类和函数是线程安全的。这些主要是与线程相关的类（例如 QMutex）和基本函数（例如 QCoreApplication::postEvent()）。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt学习-线程和QObjects</title>
    <link href="/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E7%A8%8B%E5%92%8CQObjects/"/>
    <url>/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E7%A8%8B%E5%92%8CQObjects/</url>
    
    <content type="html"><![CDATA[<p>原文地址 <a href="https://doc.qt.io/qt-6/threads-qobject.html">https://doc.qt.io/qt-6/threads-qobject.html</a></p><p>QThread 继承了QObject。它发出信号以指示线程开始或完成执行，并提供一些槽函数。</p><p>更有趣的是，QObjects 可以在多个线程中使用，发出调用其他线程中的槽的信号，并将事件发布到“存在”在其他线程中的对象。这是可能的，因为允许每个线程有自己的事件循环。</p><h2 id="QObject-重入"><a href="#QObject-重入" class="headerlink" title="QObject 重入"></a>QObject 重入</h2><p>QObject 是可重入的。 它的大多数非 GUI 子类，例如 QTimer、QTcpSocket、QUdpSocket 和 QProcess，也是可重入的，从而可以从多个线程同时使用这些类。 请注意，这些类被设计为在单个线程中创建和使用； 不能保证在一个线程中创建一个对象并从另一个线程调用它的函数。 需要注意三个约束：</p><ul><li>QObject 的子对象必须始终在创建父对象的线程中创建。 这意味着，除其他事项外，您永远不应将 QThread 对象 (this) 作为在线程中创建的对象的父对象传递（因为 QThread 对象本身是在另一个线程中创建的）。</li><li>事件驱动对象只能在单个线程中使用。具体来说，这适用于定时器机制和网络模块。例如，您不能在不是对象线程的线程中启动计时器或连接套接字。</li><li>您必须确保在删除 QThread 之前删除线程中创建的所有对象。这可以通过在 run() 实现中在堆栈上创建对象来轻松完成。</li></ul><p>尽管 QObject 是可重入的，但 GUI 类，尤其是 QWidget 及其所有子类，都不是可重入的。它们只能在主线程中使用。如前所述，还必须从该线程调用 QCoreApplication::exec()。</p><p>实际上，通过将耗时的操作放在单独的工作线程中并在工作线程完成时在主线程的屏幕上显示结果，可以很容易地解决无法在主线程以外的其他线程中使用 GUI 类的问题。 </p><p>通常，不支持在 QApplication 之前创建 QObjects，这可能会导致退出时发生奇怪的崩溃，具体取决于平台。 这意味着也不支持 QObject 的静态实例。 一个结构合理的单线程或多线程应用程序应该使 QApplication 最先创建，最后销毁 QObject。</p><h2 id="线程事件循环"><a href="#线程事件循环" class="headerlink" title="线程事件循环"></a>线程事件循环</h2><p>每个线程都可以有自己的事件循环。 初始线程使用 QCoreApplication::exec() 启动其事件循环，或者对于单对话框 GUI 应用程序，有时使用 QDialog::exec()。 其他线程可以使用 QThread::exec() 启动事件循环。 与 QCoreApplication 一样，QThread 提供了一个 exit(int) 函数和一个 quit() 槽。</p><p>线程中的事件循环使线程可以使用某些需要事件循环的非 GUI Qt 类（例如 QTimer、QTcpSocket 和 QProcess）。 它还可以将来自任何线程的信号连接到特定线程的槽。 这在下面的跨线程信号和槽部分中有更详细的解释。</p><p><img src="https://doc.qt.io/qt-6/images/threadsandobjects.png" alt="Threads, objects, and event loops"></p><p>QObject 实例存在于创建它的线程中。该对象的事件由该线程的事件循环分派。使用 QObject::thread() 可以获得 QObject 所在的线程。</p><p>QObject::moveToThread() 函数更改对象及其子对象的线程亲和性（如果对象有父对象，则不能移动该对象）。</p><p>从拥有该对象的线程（或以其他方式访问该对象）以外的线程调用 QObject 上的 delete 是不安全的，除非您保证该对象当时不在处理事件。 改用 QObject::deleteLater() ，将发布一个 DeferredDelete 事件，对象线程的事件循环最终将拾取该事件。 默认情况下，拥有 QObject 的线程是创建 QObject 的线程，但不是在调用 QObject::moveToThread() 之后。</p><p>如果没有事件循环在运行，事件将不会传递给对象。 例如，如果您在线程中创建了一个 QTimer 对象但从未调用 exec()，则 QTimer 将永远不会发出其 timeout() 信号。 调用 deleteLater() 也不起作用。 （这些限制也适用于主线程。）</p><p>您可以随时使用线程安全函数 QCoreApplication::postEvent() 手动将事件发布到任何线程中的任何对象。事件将由创建对象的线程的事件循环自动分派。</p><p>所有线程都支持事件过滤器，但限制是监视对象必须与监视对象位于同一线程中。 类似地，QCoreApplication::sendEvent()（与 postEvent() 不同）只能用于将事件分派给位于调用该函数的线程中的对象。</p><h2 id="从其他线程访问-QObject-子类"><a href="#从其他线程访问-QObject-子类" class="headerlink" title="从其他线程访问 QObject 子类"></a>从其他线程访问 QObject 子类</h2><p>QObject 及其所有子类都不是线程安全的。 这包括整个事件传递系统。 重要的是要记住，当您从另一个线程访问对象时，事件循环可能会将事件传递给您的 QObject 子类。</p><p>如果您在不在当前线程中的 QObject 子类上调用一个函数，并且该对象可能会接收事件，则必须使用互斥锁来保护对 QObject 子类内部数据的所有访问； 否则，您可能会遇到崩溃或其他不良行为。</p><p>与其他对象一样，QThread 对象存在于创建对象的线程中——而不是存在于调用 QThread::run() 时创建的线程中。 在 QThread 子类中提供槽函数通常是不安全的，除非您使用互斥体保护成员变量。</p><p>另一方面，您可以从 QThread::run() 实现中安全地发射信号，因为信号发射是线程安全的。</p><h2 id="跨线程的信号和槽"><a href="#跨线程的信号和槽" class="headerlink" title="跨线程的信号和槽"></a>跨线程的信号和槽</h2><p>Qt 支持这些信号槽连接类型：</p><ul><li><a href="https://doc.qt.io/qt-6/qt.html#ConnectionType-enum">Auto Connection</a> 自动连接（默认），如果信号在接收对象具有亲和力的线程中发出，则行为与直接连接相同。否则，行为与排队连接相同。”</li><li><a href="https://doc.qt.io/qt-6/qt.html#ConnectionType-enum">Direct Connection</a> 直接连接，当信号发出时，槽函数会立即被调用。槽函数在信号发送者的线程中执行，不一定是接收者的线程。</li><li>Queued Connection 排队连接，当控制权返回到接收方线程的事件循环时调用槽。 槽函数在接收方的线程中执行。信号发送者发送信号后立即返回，相当于异步调用</li><li>Blocking Queued Connection 阻塞排队连接，槽函数在接收方的线程中执行。信号发送者等待槽函数执行结束，相当于同步调用。注意：使用该类型连接同一个线程中的对象会造成死锁。</li><li><a href="https://doc.qt.io/qt-6/qt.html#ConnectionType-enum">Unique Connection</a> 唯一连接，该行为与自动连接相同，但只有在不复制现有连接时才会建立连接。 也就是说，如果相同的信号已经连接到同一对对象的相同插槽，则不会建立连接并且 connect() 返回 false。注意：Qt::UniqueConnections 不适用于 lambda、非成员函数和仿函数；它们仅适用于连接到成员函数。</li></ul><p>可以通过将附加参数传递给 connect() 来指定连接类型。 请注意，如果事件循环在接收方的线程中运行，那么在发送方和接收方位于不同线程中时使用直接连接是不安全的，原因与调用位于另一个线程中的对象上的任何函数是不安全的原因相同。</p><p>QObject::connect() 本身是线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt学习-隐式共享</title>
    <link href="/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-%E9%9A%90%E5%BC%8F%E5%85%B1%E4%BA%AB/"/>
    <url>/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-%E9%9A%90%E5%BC%8F%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>原文地址 <a href="https://doc.qt.io/qt-6/implicit-sharing.html">https://doc.qt.io/qt-6/implicit-sharing.html</a></p><p>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。 当作为参数传递时，隐式共享类既安全又高效，因为只传递指向数据的指针，并且只有当函数写入数据时才会复制数据，即写时复制。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>共享类由指向包含引用计数和数据的共享数据块的指针组成。</p><p>创建共享对象时，它会将引用计数设置为 1。每当新对象引用共享数据时，引用计数就会增加，而当对象取消引用共享数据时，引用计数就会减少。 当引用计数变为零时，共享数据将被删除。</p><p>在处理共享对象时，有两种复制对象的方法。 我们通常说深拷贝和浅拷贝。 深拷贝意味着复制一个对象。 浅拷贝是引用拷贝，即只是指向共享数据块的指针。 就内存和 CPU 而言，进行深拷贝可能会很昂贵。 制作浅拷贝非常快，因为它只涉及设置指针和增加引用计数。</p><p>隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。</p><p>共享的好处是程序不需要不必要地复制数据，从而减少内存使用和数据复制。对象可以很容易地被赋值，作为函数参数发送，并从函数返回。</p><p>隐式共享主要发生在幕后；程序员很少需要担心它。然而，Qt 的容器迭代器与 STL 中的容器迭代器有不同的行为。阅读隐式共享迭代器问题（后面会讲）。</p><p>在多线程应用程序中，会发生隐式共享，<a href="https://doc.qt.io/qt-6/threads-modules.html#threads-and-implicitly-shared-classes">但是要注意线程安全问题</a></p><p>在实现您自己的隐式共享类时，请使用 QSharedData 和 QSharedDataPointer 类。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>如果对象即将更改并且引用计数大于 1，则隐式共享会自动将对象从共享块中分离出来。 （这通常称为写时复制或值语义。）</p><p>隐式共享类可以控制其内部数据。 在修改其数据的任何成员函数中，它会在修改数据之前自动分离。 但是，请注意容器迭代器的特殊情况； 请参阅隐式共享迭代器问题。</p><p>使用隐式共享的 QPen 类从所有更改内部数据的成员函数中的共享数据分离。</p><p>代码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QPen::setStyle</span><span class="hljs-params">(Qt::PenStyle style)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">detach</span>();           <span class="hljs-comment">// detach from common data</span><br>    d-&gt;style = style;   <span class="hljs-comment">// set the style member</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QPen::detach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (d-&gt;ref != <span class="hljs-number">1</span>) &#123;<br>        ...             <span class="hljs-comment">// perform a deep copy</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对象将要更改，下面列出的类（见原文）会自动从公共数据中分离出来。 程序员甚至不会注意到对象是共享的。 因此，您应该将它们的单独实例视为单独的对象。 它们将始终表现为独立的对象，但具有尽可能共享数据的额外好处。 因此，您可以按值将这些类的实例作为参数传递给函数，而无需担心复制开销。</p><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">QPixmap p1, p2;<br>p1.<span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;image.bmp&quot;</span>);<br>p2 = p1;                        <span class="hljs-comment">// p1 and p2 share data</span><br><br>QPainter paint;<br>paint.<span class="hljs-built_in">begin</span>(&amp;p2);               <span class="hljs-comment">// cuts p2 loose from p1</span><br>paint.<span class="hljs-built_in">drawText</span>(<span class="hljs-number">0</span>,<span class="hljs-number">50</span>, <span class="hljs-string">&quot;Hi&quot;</span>);<br>paint.<span class="hljs-built_in">end</span>();<br></code></pre></td></tr></table></figure><p>在此示例中，p1 和 p2 共享数据直到为 p2 调用 QPainter::begin()，因为绘制像素图将修改它。</p><h2 id="隐式共享迭代器问题"><a href="#隐式共享迭代器问题" class="headerlink" title="隐式共享迭代器问题"></a>隐式共享迭代器问题</h2><p>隐式共享对 STL 样式的迭代器有另一个影响：当迭代器在容器上处于活动状态时，您应该避免复制容器。 迭代器指向一个内部结构，如果你复制一个容器，你应该非常小心你的迭代器。 例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">QList&lt;<span class="hljs-type">int</span>&gt; a, b;<br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100000</span>); <span class="hljs-comment">// make a big list filled with 0.</span><br><br>QList&lt;<span class="hljs-type">int</span>&gt;::iterator i = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// WRONG way of using the iterator i:</span><br>b = a; <span class="hljs-comment">// 此时b和a共享数据</span><br><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>; <br><span class="hljs-comment">// 修改了a的数据，a拷贝了一份，从共享数据分离</span><br><span class="hljs-comment">// 但是i仍然指向共享数据，即此时只指向b</span><br><br>b.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 此时 i 无效</span><br><br><span class="hljs-type">int</span> j = *i; <span class="hljs-comment">// 读取无效数据，可能会导致crash</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    The data from b (which i pointed to) is gone.</span><br><span class="hljs-comment">    This would be well-defined with STL containers (and (*i) == 5),</span><br><span class="hljs-comment">    but with QList this is likely to crash.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上面的示例仅显示了 QList 的问题，但所有隐式共享的 Qt 容器都存在该问题。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt学习-D-Pointer</title>
    <link href="/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-D-Pointer/"/>
    <url>/2023/11/12/Qt%E5%AD%A6%E4%B9%A0-D-Pointer/</url>
    
    <content type="html"><![CDATA[<p>原文地址 <a href="https://wiki.qt.io/D-Pointer">https://wiki.qt.io/D-Pointer</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>d-point是Qt的一种代码设计模式，可以使库的实现细节可能对其用户隐藏，并且可以在不破坏二进制兼容性（Binary compatibility）的情况下对库进行实现更改</p><h2 id="二进制兼容"><a href="#二进制兼容" class="headerlink" title="二进制兼容"></a>二进制兼容</h2><p>sdk库升级后，动态链接该库的某个app不必重新编译，仍然可以运行，可以认为该库是二进制兼容的</p><p>某些情况下会破坏二进制兼容性，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span><br> &#123;<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">private</span>:<br>    Rect m_geometry;<br> &#125;;<br> <br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Label</span> : <span class="hljs-keyword">public</span> Widget<br> &#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-function">String <span class="hljs-title">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_text;<br>    &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>     String m_text;<br> &#125;;<br></code></pre></td></tr></table></figure><p>以上代码发布为<em>WidgetLib 1.0</em>.</p><p>而在WidgetLib 1.1版本中，在Widget类中增加了成员变量m_stylesheet</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span><br> &#123;<br>    <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">private</span>:<br>     Rect m_geometry;<br>     String m_stylesheet; <span class="hljs-comment">// NEW in WidgetLib 1.1</span><br> &#125;;<br> <br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Label</span> : <span class="hljs-keyword">public</span> Widget<br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">// ...</span><br>     <span class="hljs-function">String <span class="hljs-title">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">     </span>&#123;<br>         <span class="hljs-keyword">return</span> m_text;<br>     &#125;<br> <br> <span class="hljs-keyword">private</span>:<br>     String m_text;<br> &#125;;<br></code></pre></td></tr></table></figure><p>升级为WidgetLib 1.1后，原来使用WidgetLib 1.0的app就会crash</p><p>原因是通过添加一个新的数据成员，我们最终改变了 Widget 和 Label 对象的大小。当C++ 编译器生成代码时，它使用偏移量来访问对象内的数据。</p><table><thead><tr><th align="center">Label object layout in WidgetLib 1.0</th><th align="center">Label object layout in WidgetLib 1.1</th></tr></thead><tbody><tr><td align="center">m_geometry &lt;offset 0&gt;</td><td align="center">m_geometry &lt;offset 0&gt;</td></tr><tr><td align="center">- - -</td><td align="center">m_stylesheet &lt;offset 1&gt;</td></tr><tr><td align="center">m_text &lt;offset 1&gt;</td><td align="center">- - -</td></tr><tr><td align="center">- - -</td><td align="center">m_text &lt;offset 2&gt;</td></tr></tbody></table><p>Label::text()原来访问的offset 1的位置m_text，现在是m_stylesheet的位置，就会crash</p><p>至于为什么 Label::text() 的偏移量计算代码最终出现在 CuteApp 二进制文件中而不是 WidgetLib 二进制文件中。 答案是 Label::text() 的代码是在头文件中定义的，编译器最终将其内联。</p><p>如果Label::text()不是内联的，也会有问题。C++ 编译器依赖于对象的大小在编译时和运行时相同。 例如，堆栈卷绕/展开——如果您在堆栈上创建了一个 Label 对象，编译器会生成代码以在编译时根据 Label 的大小在堆栈上分配空间。 由于 Label 的大小在 WidgetLib 1.1 的运行时是不同的，Label 的构造函数会覆盖现有的堆栈数据并最终破坏堆栈。</p><p>总之，一旦您的库发布，<strong>永远不要更改导出的（即对用户可见的）C++ 类的大小或布局（不要四处移动数据）</strong>。 C++ 编译器生成代码时假定类中数据的大小或顺序在编译应用程序后不会改变。</p><h2 id="d-point"><a href="#d-point" class="headerlink" title="d-point"></a>d-point</h2><p>诀窍是通过仅存储单个指针来保持库的所有公共类的大小不变。 该指针指向包含所有数据的私有/内部数据结构。 这个内部结构的大小可以收缩或增长而不会对应用程序产生任何副作用，因为指针仅在库代码中访问，并且从应用程序的角度来看，对象的大小永远不会改变 - 它始终是指针。 该指针称为 d 指针（d-point）。</p><p>以下是其实现代码</p><p><strong>widget.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetPrivate</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span><br>&#123;<br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-function">Rect <span class="hljs-title">geometry</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-comment">// ... </span><br><br><span class="hljs-keyword">private</span>:<br>   WidgetPrivate *d_ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里WidgetPrivate作为内部类，不包含其头文件，仅做前置声明</p><p><strong>widget_p.h</strong>，WidgetPrivate类的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WidgetPrivate</span><br>&#123;<br>    Rect geometry;<br>    String stylesheet;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>widget.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget_p.h&quot;</span></span><br><br>Widget::<span class="hljs-built_in">Widget</span>() : <span class="hljs-built_in">d_ptr</span>(<span class="hljs-keyword">new</span> WidgetPrivate)<br>&#123;<br>    <span class="hljs-comment">// Creation of private data</span><br>&#125;<br><br><span class="hljs-function">Rect <span class="hljs-title">Widget::geometry</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// The d-ptr is only accessed in the library code</span><br>    <span class="hljs-keyword">return</span> d_ptr-&gt;geometry;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里#include “widget_p.h”</p><p>Label类继承Widget类，Label类也有自己的私有类LabelPrivate</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Label</span> : <span class="hljs-keyword">public</span> Widget<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">String <span class="hljs-title">text</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Each class maintains its own d-pointer</span><br>    LabelPrivate *d_ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>label.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Unlike WidgetPrivate, the author decided LabelPrivate</span><br><span class="hljs-comment">// to be defined in the source file itself</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LabelPrivate</span><br>&#123;<br>    String text;<br>&#125;;<br><br>Label::<span class="hljs-built_in">Label</span>() : <span class="hljs-built_in">d_ptr</span>(<span class="hljs-keyword">new</span> LabelPrivate)<br>&#123;<br>&#125;<br><br><span class="hljs-function">String <span class="hljs-title">Label::text</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> d_ptr-&gt;text;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述结构，app 永远不会直接访问 d 指针。由于 d 指针仅在 WidgetLib 中访问，并且 WidgetLib 会在每次发布时重新编译，因此 Private 类可以自由更改，而不会影响 app。</p><p>使用d-point还有其他的好处</p><ul><li>隐藏了实现细节——我们可以仅将 WidgetLib 与头文件和二进制文件一起发布。 .cpp 文件可以是封闭源代码。</li><li>头文件没有实现细节，可以作为 API 参考。</li><li>由于实现所需的头文件已从头文件移动到实现（源）文件中，因此编译速度要快得多。</li></ul><h2 id="q-point"><a href="#q-point" class="headerlink" title="q-point"></a>q-point</h2><p>到目前为止，我们只看到了 d 指针作为 C 风格的数据结构。 实际上，它包含私有方法（辅助函数）。 例如，LabelPrivate 可能有一个 getLinkTargetFromPoint() 辅助函数，单击鼠标时需要它来查找链接目标。 在许多情况下，这些辅助方法需要访问公共类，即一些来自 Label 或其基类 Widget 的函数。 例如，辅助方法 setTextAndUpdateWidget() 可能需要调用 Widget::update()，这是一个公共方法来安排重绘 Widget。 因此，<strong>WidgetPrivate 存储了一个指向公共类的指针，称为 q 指针（q-point）</strong>。 为 q 指针修改上面的代码，我们得到：</p><p><strong>widget.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetPrivate</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">Rect <span class="hljs-title">geometry</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    WidgetPrivate *d_ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>widget_p.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WidgetPrivate</span><br>&#123;<br>    <span class="hljs-comment">// Constructor that initializes the q-ptr</span><br>    <span class="hljs-built_in">WidgetPrivate</span>(Widget *q) : <span class="hljs-built_in">q_ptr</span>(q) &#123; &#125;<br>    Widget *q_ptr; <span class="hljs-comment">// q-ptr points to the API class</span><br>    Rect geometry;<br>    String stylesheet;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>widget.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget_p.h&quot;</span></span><br><span class="hljs-comment">// Create private data.</span><br><span class="hljs-comment">// Pass the &#x27;this&#x27; pointer to initialize the q-ptr</span><br>Widget::<span class="hljs-built_in">Widget</span>() : <span class="hljs-built_in">d_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">WidgetPrivate</span>(<span class="hljs-keyword">this</span>))<br>&#123;<br>&#125;<br><br><span class="hljs-function">Rect <span class="hljs-title">Widget::geometry</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// the d-ptr is only accessed in the library code</span><br>    <span class="hljs-keyword">return</span> d_ptr-&gt;geometry;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>label.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Label</span> : <span class="hljs-keyword">public</span> Widget<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">String <span class="hljs-title">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    LabelPrivate *d_ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>label.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LabelPrivate</span><br>&#123;<br>    <span class="hljs-built_in">LabelPrivate</span>(Label *q) : <span class="hljs-built_in">q_ptr</span>(q) &#123; &#125;<br>    Label *q_ptr;<br>    String text;<br>&#125;;<br><br>Label::<span class="hljs-built_in">Label</span>() : <span class="hljs-built_in">d_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">LabelPrivate</span>(<span class="hljs-keyword">this</span>))<br>&#123;<br>&#125;<br><br><span class="hljs-function">String <span class="hljs-title">Label::text</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> d_ptr-&gt;text;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，创建单个 Label 导致为 LabelPrivate 和 WidgetPrivate 分配内存。 如下图所示</p><img src="/Users/yuhong/Library/Application Support/typora-user-images/image-20230422225911213.png" alt="image-20230422225911213" style="zoom:50%;" /><p>如果我们对 Qt 采用这种策略，对于像 QListWidget 这样的类，情况会变得更糟——它在类继承层次结构中有 6 层深，这将导致多达 6 次内存分配！</p><p>可以通过私有类设置继承层次结构并让实例化的类一直向上传递 d 指针来优化</p><p>请注意，在继承 d 指针时，私有类的声明必须在单独的文件中，例如 widget_p.h。不再可能在 widget.cpp 文件中声明它。</p><p><strong>widget.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// only subclasses may access the below</span><br>    <span class="hljs-comment">// allow subclasses to initialize with their own concrete Private</span><br>    <span class="hljs-built_in">Widget</span>(WidgetPrivate &amp;d);<br>    WidgetPrivate *d_ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>widget_p.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WidgetPrivate</span><br>&#123;<br>    <span class="hljs-built_in">WidgetPrivate</span>(Widget *q) : <span class="hljs-built_in">q_ptr</span>(q) &#123; &#125; <span class="hljs-comment">// constructor that initializes the q-ptr</span><br>    Widget *q_ptr; <span class="hljs-comment">// q-ptr that points to the API class</span><br>    Rect geometry;<br>    String stylesheet;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>widget.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget::<span class="hljs-built_in">Widget</span>() : <span class="hljs-built_in">d_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">WidgetPrivate</span>(<span class="hljs-keyword">this</span>))<br>&#123;<br>&#125;<br><br>Widget::<span class="hljs-built_in">Widget</span>(WidgetPrivate &amp;d) : <span class="hljs-built_in">d_ptr</span>(&amp;d)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>label.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Label</span> : <span class="hljs-keyword">public</span> Widget<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Label</span>();<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Label</span>(LabelPrivate &amp;d); <span class="hljs-comment">// allow Label subclasses to pass on their Private</span><br>    <span class="hljs-comment">// notice how Label does not have a d_ptr! It just uses Widget&#x27;s d_ptr.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>label.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget_p.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LabelPrivate</span> : <span class="hljs-keyword">public</span> WidgetPrivate<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    String text;<br>&#125;;<br><br>Label::<span class="hljs-built_in">Label</span>()<br> : <span class="hljs-built_in">Widget</span>(*<span class="hljs-keyword">new</span> LabelPrivate) <span class="hljs-comment">// initialize the d-pointer with our own Private</span><br>&#123;<br>&#125;<br><br>Label::<span class="hljs-built_in">Label</span>(LabelPrivate &amp;d) : <span class="hljs-built_in">Widget</span>(d)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们现在创建一个 Label 对象时，它会创建一个 LabelPrivate（它是 WidgetPrivate 的子类）。 它将具体的 d 指针传递给 Widget 的受保护构造函数！ 现在，当创建一个 Label 对象时，只有一次内存分配。 Label 还有一个受保护的构造函数，它的子类可以使用它来提供自己的私有类。如下图所示</p><img src="/Users/yuhong/Library/Application Support/typora-user-images/image-20230422230845253.png" alt="image-20230422230845253" style="zoom:50%;" /><h2 id="Qt中的d指针"><a href="#Qt中的d指针" class="headerlink" title="Qt中的d指针"></a>Qt中的d指针</h2><p>在 Qt 中，几乎每个公共类都使用 d 指针方法。 唯一不使用它的情况是事先知道该类永远不会添加额外的成员变量。 例如，对于像 QPoint、QRect 这样的类，不需要添加新成员，因此数据成员直接存储到类本身而不是使用 d 指针。</p><p>请注意，在 Qt 中，所有 Private 对象的基类都是 QObjectPrivate。</p><h3 id="Q-D-and-Q-Q"><a href="#Q-D-and-Q-Q" class="headerlink" title="Q_D and Q_Q"></a>Q_D and Q_Q</h3><p>我们在上一步中进行的优化的一个副作用是 q-ptr 和 d-ptr 是 Widget 和 WidgetPrivate 类型。这意味着以下将不起作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Label::setText</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// won&#x27;t work! since d_ptr is of type WidgetPrivate even though</span><br>   <span class="hljs-comment">// it points to LabelPrivate object</span><br>   d_ptr-&gt;text = text;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，当访问子类中的 d 指针时，我们需要将 static_cast 转换为适当的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Label::setText</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>    LabelPrivate *d = <span class="hljs-built_in">static_cast</span>&lt;LabelPrivate*&gt;(d_ptr); <span class="hljs-comment">// cast to our private type</span><br>    d-&gt;text = text;<br>&#125;<br></code></pre></td></tr></table></figure><p>如您所见，到处都是 static_cast 并不是一件好事。相反，在 src/corelib/global/qglobal.h 中定义了两个宏，这使得它变得直截了当</p><p><strong>global.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Q_D(Class) Class##Private * const d = d_func()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Q_Q(Class) Class * const q = q_func()</span><br></code></pre></td></tr></table></figure><p><strong>label.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// With Q_D you can use the members of LabelPrivate from Label</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Label::setText</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_D</span>(Label);<br>    d-&gt;text = text;<br>&#125;<br><br><span class="hljs-comment">// With Q_Q you can use the members of Label from LabelPrivate</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LabelPrivate::someHelperFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_Q</span>(Label);<br>    q-&gt;<span class="hljs-built_in">selectAll</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Q-DECLARE-PRIVATE-and-Q-DECLARE-PUBLIC"><a href="#Q-DECLARE-PRIVATE-and-Q-DECLARE-PUBLIC" class="headerlink" title="Q_DECLARE_PRIVATE and Q_DECLARE_PUBLIC"></a>Q_DECLARE_PRIVATE and Q_DECLARE_PUBLIC</h3><p>Qt 类在公共类中有一个 Q_DECLARE_PRIVATE 宏。宏是这么写的：</p><p><strong>qglobal.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Q_DECLARE_PRIVATE(Class)\</span><br><span class="hljs-meta">inline Class##Private* d_func() &#123;\</span><br><span class="hljs-meta">    return reinterpret_cast<span class="hljs-string">&lt;Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">inline const Class##Private* d_func() const &#123;\</span><br><span class="hljs-meta">    return reinterpret_cast<span class="hljs-string">&lt;const Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">friend class Class##Private;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Q_DECLARE_PUBLIC(Class)                                    \</span><br><span class="hljs-meta">inline Class* q_func() &#123; return static_cast<span class="hljs-string">&lt;Class *&gt;</span>(q_ptr); &#125; \</span><br><span class="hljs-meta">inline const Class* q_func() const &#123; return static_cast<span class="hljs-string">&lt;const Class *&gt;</span>(q_ptr); &#125; \</span><br><span class="hljs-meta">friend class Class;</span><br></code></pre></td></tr></table></figure><p>这个宏可以这样使用：</p><p><strong>qlabel.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QLabel</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Q_DECLARE_PRIVATE</span>(QLabel)<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个想法是 QLabel 提供了一个允许访问其私有内部类的函数 d_func() 。 该方法本身是私有的（因为宏位于 qlabel.h 的私有部分中）。 然而，d_func() 可以被 QLabel 的友类调用。 这主要用于无法使用公共 api 访问某些 QLabel 信息的 Qt 类访问信息。 举一个奇怪的例子，QLabel 可能会跟踪用户点击链接的次数。 但是，没有公共 API 来访问此信息。 QStatistics 是一个需要此信息的类。 Qt 开发人员会将 QStatistics 添加为 QLabel 的好友，然后 QStatistics 可以执行 label-&gt;d_func()-&gt;linkClickCount。</p><p>d_func 还具有强制 const 正确性的优点：在 MyClass 的 const 成员函数中，您需要一个 Q_D(const MyClass)，因此您只能调用 MyClassPrivate 中的 const 成员函数。 使用裸 d_ptr，您还可以调用非常量函数。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>mywidget.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYWIDGET_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYWIDGET_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWidgetPrivate</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWidget</span> : <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyWidget</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">api</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Q_DECLARE_PRIVATE</span>(MyWidget)<br>    MyWidgetPrivate *d_ptr;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYWIDGET_H</span></span><br></code></pre></td></tr></table></figure><p><strong>mywidget_p.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYWIDGETPRIVATE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYWIDGETPRIVATE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mywidget.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWidgetPrivate</span> : <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    <span class="hljs-function">Q_OBJECT</span><br><span class="hljs-function">    <span class="hljs-title">Q_DECLARE_PUBLIC</span><span class="hljs-params">(MyWidget)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span>:</span><br><span class="hljs-function">    explicit MyWidgetPrivate(QObject *parent =</span> <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    MyWidget *q_ptr;<br>    QString text;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYWIDGETPRIVATE_H</span></span><br><br></code></pre></td></tr></table></figure><p><strong>mywidget.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mywidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mywidget_p.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QDebug&gt;</span></span><br><br>MyWidget::<span class="hljs-built_in">MyWidget</span>(QObject *parent)<br>    : QObject&#123;parent&#125;, <span class="hljs-built_in">d_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyWidgetPrivate</span>(<span class="hljs-keyword">this</span>))<br><br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyWidget::fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_D</span>(MyWidget);<br>    <span class="hljs-keyword">return</span> d-&gt;<span class="hljs-built_in">func</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyWidget::api</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; __PRETTY_FUNCTION__;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>mywidget_p.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mywidget_p.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QDebug&gt;</span></span><br><br>MyWidgetPrivate::<span class="hljs-built_in">MyWidgetPrivate</span>(QObject *parent)<br>    : QObject&#123;parent&#125;<br>&#123;<br>    text = <span class="hljs-string">&quot;aaa&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyWidgetPrivate::func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; __PRETTY_FUNCTION__;<br>    <span class="hljs-built_in">Q_Q</span>(MyWidget);<br>    q-&gt;<span class="hljs-built_in">api</span>();<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; text;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mywidget.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><br>    MyWidget *myWidget = <span class="hljs-keyword">new</span> MyWidget;<br>    myWidget-&gt;<span class="hljs-built_in">fun</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
